---
layout:     post
title:      （JVM学习笔记二）垃圾收集器和内存分配策略
subtitle:   
date:       2019-3-20
author:     BY xukexiang
header-img: img/charlotte/b2f68e7ebd6314a8358661a765ca9095527eeee1.jpg
catalog: true
tags:
    - Typora
---

### 1.对象已死吗
***

#### 1.1 引用计数算法
优势：实现简单，效率高。

致命缺陷：无法解决对象相互引用的问题——会导致对象的引用虽然存在，
但是已经不可能再被使用，却无法被回收。

#### 1.2 可达性分析算法

对象到GC Roots没有引用链，则回收。

GC Roots中的对象包括：

- （1）Java虚拟机栈中引用的对象。
- （2）方法区中类静态属性引用的对象。
- （3）方法区中常量引用的对象。
- （4）本地方法栈中Native方法（JNI）引用的对象。

#### 1.3 关于引用

JDK1.2之后，Java对引用进行了扩充。

- （1）强引用：Object obj = new Object()，不会被jvm回收
- （2）软引用：在内存溢出异常发生之前才被强制回收。
- （3）弱引用：延迟到下次垃圾回收之前再被回收。
- （4）虚引用：仅为了在被回收时收到一个系统通知。

#### 1.4 不可达对象是否非死不可？finalize方法

不是。要真正“死亡”，至少得被标记两次：如果对象在进行可达性分析之后没有与GC Roots相连接的引用链，那么将会第一次被标记且进行一次筛选，筛选条件是该对象是否有必要执行finalize()方法（没有覆盖finalize()方法或者该方法已被调用，就没有必要执行）。
如果有必要执行则将会放在一个F-Queue的队列之中，被JVM自动建立、低优先级的Finalizer线程去执行它，但JVM只是触发这个方法，并不会等待它运行结束（防止死循环等导致GC系统崩溃）。如果在这个过程中对象重新和引用链上任意一个对象建立了关联（如把自己的this赋值给了某个类变量或对象的成员变量），那么第二次将会被移除即将回收的集合。若没有逃脱，那基本上就被回收了。

对象可以在被GC时自我拯救，这种机会只有一次，因为一个对象的finalize()最多只能被系统自动调用一次

不建议使用finalize来拯救对象，运行代价高昂，不确定性大，无法保证各个对象的调用顺序。


#### 1.5 回收方法区

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

### 2.垃圾收集算法

#### 2.1 标记清除算法（Mark-Sweep）

分为标记和清除两个阶段：先标记出需要回收的对象，在标记完成后统一回收所有被标记的对象。

不足之处：效率问题，标记和清除效率都不高。空间问题，标记清除之后会产生大量不连续的内存碎片，
空间碎片太多可能会导致以后在程序运行过程中分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。

#### 2.2 复制算法（适用于新生代不适用老年代）

将可用内存划分为大小相等的两块，每次只使用其中的一块。当这块用完了，就将还存货的复制到另一块上，然后将这一块一次性清除。运行还算高效，但不足之处是将内存缩小为原来的一半，代价太高。用空间换时间。

商业虚拟机都是采用该方法来回收新生代，因为新生代98%都是朝生夕死的。
较大Eden和两个较小的survivor空间。每次使用其中一块Eden和survivor，
回收时将存活的放入另一块survivor中，再清理掉之前的。
默认比例8:1:1。survivor空间不够时，
需要依赖其他内存（老年代）进行分配担保，即让对象进入老年代。

#### 2.3 标记-整理算法（适用于老年代的算法）

复制在对象存活率较高时效率很低。根据老年代的特点提出该算法。
标记过程同标记清除一样，但不是直接对可回收对象进行清理，
而是让存活对象朝着一端移动，然后直接清理掉端边界外的内存。


#### 2.4 分代收集算法

将Java堆分为新生代和老年代，永久代是方法区。
在新生代中，对象有大量死去少量存活，就选用复制方法，
而老年代中因为存活率高且没有额外空间对它进行分配担保，
就必须使用“标记清除”或“标记整理”来进行回收。

### 3.HotSpot的算法实现

#### 1.枚举根结点

GC Roots在全局性引用（常量或类静态属性）和执行上下文（栈帧的本地变量表）中，
如果太多的话不可能一一进行检查，太消耗时间。
同时，GC检查时会出现GC停顿，即可达性分析工作必须在一个能确保一致性的快照中进行，
此时在整个分析期间整个执行系统仿佛被冻结，对象的引用关系不会出现变化，
否则分析结果无法保证。即GC进行时必须停顿所有的Java执行线程。
目前虚拟机使用的都是准确式GC
（虚拟机自己知道内存中某个位置的具体数据是什么类型，
即知道哪些地方存放着对象引用）。在类加载完成时，
使用OopMap数据结构（OOP，普通对象指针）来进行查看对象的存放地址。
GC扫描时就可以直接得到信息。

#### 2.安全点

GC Roots枚举的问题：可能导致引用关系变化，
或者说OopMap内容变化的指令非常多。如果每一条指定都生成OopMap，
那将会需要大量的额外空间，GC的空间成本将会变很高。

安全点：没有每条指令都生成OopMap，只在特定位置记录了信息，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。由于安全点的选定既不能太少以致于让GC等待时间太长，也不能太过于频繁以致于过分增大运行时的负荷。因此，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”来选定的。长时间运行即指令序列复用，例如方法调用、循环跳转、异常跳转等。

另一个问题是如何在GC发生时让所有线程（不包括执行JNI调用的线程）都到最近的安全点上再停顿下来。

有两种方式：抢先式中断和主动式中断。

抢先式中断即不需要线程的先执行代码主动配合，而是在GC发生时，先全部中断，然后发现有线程中断的不在安全点上，就恢复线程，让其跑到安全点上再停顿。（几乎没用这种方式。）

主动式中断： 当GC需要中断时，不直接对线程操作，仅仅简单设置一个标志，各线程主动去轮询这个标志，发现中断标志时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。


#### 3.安全区域

安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的安全点。
但是对于不执行（即没有分配CPU时间）的程序，
如线程处于sleep或Blocked状态，线程就无法响应JVM的中断请求，
走到安全点去挂起。JVM也不太可能等待线程重新被分配CPU时间。
这时就需要安全区域来解决了。

安全区域即在一段代码片段中，引用关系不会发生变化。
在这个区域任意地方开始GC都是安全的。可以看作是被扩展了的安全点。
线程到达安全区域时，先标识自己进入安全区域。
当这段时间内JVM要发起GC时，就不用管标识安全区域状态的线程了。
当线程要离开安全区域时，先检查系统是否完成了根结点枚举或整个GC过程
，完成了就继续执行，没有就等待直到收到可以安全离开安全区域的信号为止。

### 4.垃圾收集器

以下为JDK1.7 Update14之后的HotSpot虚拟机的所有收集器
![](/img/1349278110_8410.jpg)


垃圾回收器从线程运行情况分类有三种

1. 串行回收，Serial回收器，单线程回收，全程stw；

2. 并行回收，名称以Parallel开头的回收器，多线程回收，全程stw；

3. 并发回收，cms与G1，多线程分阶段回收，只有某阶段会stw；

上面为年轻代，下面为年老代。有连线的可以搭配使用。G1收集器仍处于实验状态。

#### 1.Serial收集器 

最悠久，最基本的收集器，JDK1.3.1之前唯一一个。单线程收集器。
只使用一个CPU或一条收集线程去完成垃圾收集工作，且在收集时，必须暂停其他所有的工作线程，直到收集结束。
新生代采取复制算法。老年代采取标记整理算法。Stop the world
依然是虚拟机运行在Client模式下的默认新生代收集器。简单而高效（与其他收集器单线程相比），
对于单个CPU环境来说，Serial收集器由于没有线程交互的开销，
专注于垃圾回收，因此能获得最高的单线程收集效率。
收集一两百兆的新生代，停顿时间完全可以控制在200ms以内。越少越小。

#### 2.ParNew收集器

Serial收集器的多线程版。多条线程进行垃圾收集。其余和Serial收集器一样。
是许多运行在Server模式下的虚拟机中首选的新生代收集器，
因为除了Serial以外只有它能与CMS收集器配合工作。


JDK1.5中使用CMS收集器，Concurrent Mark Sweep,真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。它无法和JDK1.4中的新生代收集器Parallel Scavenge配合工作。

ParNew在单线程会存在线程交互的开销，效果并不能比Serial好。但随着CPU的数量增加，它对于GC时系统资源的有效利用还是很有好处的。默认开启的收集线程数与CPU数量相同。可以使用-XX:ParallerGCThreads来限制垃圾收集的线程数。



#### 3.并发与并行

并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。

并发（Concureent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另外一个CPU上。


#### 4.Parallel Scavenge收集器（吞吐量优先）

新生代收集器，使用复制算法。并行的多线程收集器。

CMS的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而PS收集器的目的则是达到一个可控制的吞吐量（Throughput）。吞吐量即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间））。

停顿时间越短越适合用户交互的程序。高吞吐量可以高效利用CPU时间，尽快完成运算，适合在后台运算而不需太懂交互的任务。

Parallel Scavenge收集器可以精确控制吞吐量，控制最大垃圾收集停顿时间-XX:MaxGCPauseMillis，直接设置吞吐量大小-XX:GCTimeRatio。

GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的。PS收集器也为“吞吐量优先”收集器。

#### 5.Serial Old收集器

Serial老年代版本，单线程收集器。老年代采取使用标记整理算法。
给Client模式下的虚拟机使用。

可以与JDK1.5及之前的Parallel Scavenge搭配使用；作为CMS收集器的后备预案，
在并发收集发生Concureent Mode Failure时使用。

#### 6.Parallel Old收集器

Parallel Old收集器，Parallel Scavenge老年代版本，多线程，标记整理。JDK1.6。没有PO时只有SO，单线程老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，
这种组合的吞吐量还不一定有ParNew+CMS给力。
在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑PS+PO收集器组合。

#### 7.CMS 收集器

Concurrent Mark Sweep，以获取最短回收停顿时间为目标的收集器。
互联网站或B/S系统。标记-清除算法。并发收集，低停顿。

① 初始标记；Stop the World，仅标记GCRoots能关联的对象，速度很快。

② 并发标记；进行GCRootsTracing的过程。

③ 重新标记；修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。比1长但远比2短。

④ 并发清除；并发清除与并发标记耗时最长。收集器线程都可以与用户线程一起工作。并发清理以后重置线程。


初始标记、从新标记这两个步骤仍然需要“stop the world”，
初始标记仅仅只是标记一下GC Roots能直接关联到的对象，熟读很快，
并发标记阶段就是进行GC Roots Tracing，
而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生表动的那一部分对象的标记记录
，这个阶段的停顿时间一般会比初始标记阶段稍长点，但远比并发标记的时间短。

CMS是一款优秀的收集器，主要优点：并发收集、低停顿。

缺点：
a.CMS对CPU资源非常敏感。面向并发设计的程序都对CPU敏感。不会导致用户线程停顿，但由于占用了CPU资源而导致应用程序变慢，总吞吐量降低。默认启动的回收线程数为（CPU数+3）/4。增量式CMS，i-CMS,尽量减少GC线程独占资源的时间，对用户程序影响较小，但垃圾收集过程加长，现已不提倡使用。

b.CMS无法处理浮动垃圾（Floating Garbage），
可能出现Concurrent Mode Failure失败而导致另一次Full GC的产生。
并发清理时用户线程还在运行着，新的垃圾不断产生。
在标记之后无法在当次收集中处理它们，只好留待下一次GC时再清理。
即为浮动垃圾。还需要预留足够空间给用户线程使用，CMS收集器不能象其他收集器那样等到老年代几乎满了再收集。若在此期间内存无法满足需要，就会出现CMF失败，虚拟机将启动后背方案：临时启用SO来重新进行老年代收集，停顿时间就加长。

c.CMS是一款“标记--清除”算法实现的收集器，
容易出现大量空间碎片。当空间碎片过多，
将会给大对象分配带来很大的麻烦，往往会出现老年代还有很大空间剩余，
但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。

#### 8.G1收集器

Garbage-First，面向服务端的垃圾收集器。

- 并行和并发： G1能充分的利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短停顿时间

- 分代收集： G1中任然保留了分代，但是G1不需要搭配其他的垃圾收集器，可以自行完成新生代和老年代的内存回收。但他能采用不同的方式去处理新创建的对象、已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果

- 空间整合： G1整体上是基于标记 - 整理算法，但从局部的两个Region来看又是基于复制算法。总之就是没有空间碎片

- 可预测的停顿： G1在追求低停顿的目标时还建立了可预测的停顿时间模型，能让使用者明确顶端时间在一个M毫秒内的时间片段，消耗在垃圾收集上的时间不能超过N毫秒。这是G1比CMS先进的地方

为了避免Java堆中全区域的垃圾收集，G1跟踪各个堆里面的垃圾堆积的价值大小，价值通过回收所获得的空间大小和回收所需的时间的经验值来衡量。维护一个Region的优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证在有限时间内可以获取尽可能高的收集效率。

内存管理：

- 将整个java堆划分为多个大小形同的区域region，新生代和老年代都是region的集合。可以有计划的避免在全区域内进行垃圾收集。

- 回收方式：跟踪每一个region里面的垃圾堆积的价值大小（回收所得的空间大小以及所需耗费时间的经验值），维护一个优先列表，每次根据允许的回收时间，优先回收价值最大的region（GI名字由来），

- region之间的引用，新生代和老年代之间的引用根据remebered set来避免全盘扫描，每一个region都维护一个remebered set，

- 初始标记-》并发标记-》最终标记-》筛选回收，类CMS


1.初始标记；

需要停顿线程，仅标记GC Roots能直接的关联到的对象，标记TAMS，指明下一阶段用户程序创建对象的Region。

2.并发标记；

从GC Roots开始对堆中对象进行可达性分析，可与用户线程并发执行。

3.最终标记；

需要停顿线程。修改那些在并发标记阶段由于用户线程继续运行而导致标记产生变动的那一部分标记记录。虚拟机把它们记录在Remembered Set Logs中，最终标记阶段的任务就是把Remembered Set Logs中的内容合并到Remembered Set中。

4.筛选回收；

首先根据各个Region的回收价值和成本排序，按照用户期望的GC停顿时间来指定回收计划。可停顿也可与用户线程并发。


### 内存分配与回收策略

堆内存的划分根据不同的参数，不同的垃圾收集器会有些不太一样，所以我这里说一下通常的情况：

如图，通常情况下，堆空间划分两个年代，新生代(New Generation)，老年代（Old Generation）。
而新生代还可以继续划分为三个区域。一个就是Eden区，另两个就是大小相等的Survivor区(From,To)。


#### 各类型GC

- Minor GC:指发生在新生代的垃圾收集动作，非常频繁，速度较快。

- Major GC : 指发生在老年代的GC，出现Major GC，经常会伴随一次Minor GC(不一定)，因为Major GC可能是Minor GC引起的，不频繁。

- Full GC:指发生在老年代和新生代的GC，速度很慢

其实Major GC和Full Gc有时候可以说的同一个说法，因为很多实用Major GC都是Minor Gc引起的。


#### 新生对象优先分配Eden区
大多数情况下，对象在新生代Eden区分配，当Eden区没有足够的空间进行分配时，
虚拟机会发起一次Minor GC，既在新生代发起一次GC

#### 大对象直接进入老年代Old Generation
大对象直接进入老年代，何为大对象？大对象就是需要大量连续内存空间的Java对象，最经典的就是那种很长的字符串和数组

#### 长期存活的对象将进入老年代Old Generation
虚拟机给每个对象定义了一个对象年龄(Age)计数器，如果对象在Eden出生并经过了第一次Minor Gc任然存活，并且被Survivor容纳，那将移入Survivor区，并且对象年龄设置为1。对象在Survivor每熬过一次Minor Gc，年龄就加1。
当年龄到达了一定的程度(默认15岁)，就会被晋升到老年代中。
当然还有一种情况不一定要到达年龄阈值才能晋升到老年代，
比如Survivor的相同年龄的所有对象大小总和大于Survivor空间的一半，
那么年龄大于或等待该年龄的对象就直接进入老年代了。
