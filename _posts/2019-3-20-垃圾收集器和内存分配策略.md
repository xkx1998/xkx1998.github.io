---
layout:     post
title:      （JVM学习笔记二）垃圾收集器和内存分配策略
subtitle:   
date:       2019-3-20
author:     BY xukexiang
header-img: img/charlotte/b2f68e7ebd6314a8358661a765ca9095527eeee1.jpg
catalog: true
tags:
    - Typora
---

### 1.对象已死吗
***

#### 1.1 引用计数算法
优势：实现简单，效率高。

致命缺陷：无法解决对象相互引用的问题——会导致对象的引用虽然存在，
但是已经不可能再被使用，却无法被回收。

#### 1.2 可达性分析算法

对象到GC Roots没有引用链，则回收。

GC Roots中的对象包括：

- （1）Java虚拟机栈中引用的对象。
- （2）方法区中类静态属性引用的对象。
- （3）方法区中常量引用的对象。
- （4）本地方法栈中Native方法（JNI）引用的对象。

#### 1.3 关于引用

JDK1.2之后，Java对引用进行了扩充。

- （1）强引用：Object obj = new Object()，不会被jvm回收
- （2）软引用：在内存溢出异常发生之前才被强制回收。
- （3）弱引用：延迟到下次垃圾回收之前再被回收。
- （4）虚引用：仅为了在被回收时收到一个系统通知。

#### 1.4 不可达对象是否非死不可？finalize方法

不是。要真正“死亡”，至少得被标记两次：如果对象在进行可达性分析之后没有与GC Roots相连接的引用链，那么将会第一次被标记且进行一次筛选，筛选条件是该对象是否有必要执行finalize()方法（没有覆盖finalize()方法或者该方法已被调用，就没有必要执行）。
如果有必要执行则将会放在一个F-Queue的队列之中，被JVM自动建立、低优先级的Finalizer线程去执行它，但JVM只是触发这个方法，并不会等待它运行结束（防止死循环等导致GC系统崩溃）。如果在这个过程中对象重新和引用链上任意一个对象建立了关联（如把自己的this赋值给了某个类变量或对象的成员变量），那么第二次将会被移除即将回收的集合。若没有逃脱，那基本上就被回收了。

对象可以在被GC时自我拯救，这种机会只有一次，因为一个对象的finalize()最多只能被系统自动调用一次

不建议使用finalize来拯救对象，运行代价高昂，不确定性大，无法保证各个对象的调用顺序。


#### 1.5 回收方法区

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。

### 2.垃圾收集算法

#### 2.1 标记清除算法（Mark-Sweep）

分为标记和清除两个阶段：先标记出需要回收的对象，在标记完成后统一回收所有被标记的对象。

不足之处：效率问题，标记和清除效率都不高。空间问题，标记清除之后会产生大量不连续的内存碎片，
空间碎片太多可能会导致以后在程序运行过程中分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。

#### 2.2 复制算法（适用于新生代不适用老年代）

将可用内存划分为大小相等的两块，每次只使用其中的一块。当这块用完了，就将还存货的复制到另一块上，然后将这一块一次性清除。运行还算高效，但不足之处是将内存缩小为原来的一半，代价太高。用空间换时间。

商业虚拟机都是采用该方法来回收新生代，因为新生代98%都是朝生夕死的。
较大Eden和两个较小的survivor空间。每次使用其中一块Eden和survivor，
回收时将存活的放入另一块survivor中，再清理掉之前的。
默认比例8:1:1。survivor空间不够时，
需要依赖其他内存（老年代）进行分配担保，即让对象进入老年代。

#### 2.3 标记-整理算法（适用于老年代的算法）

复制在对象存活率较高时效率很低。根据老年代的特点提出该算法。
标记过程同标记清除一样，但不是直接对可回收对象进行清理，
而是让存活对象朝着一端移动，然后直接清理掉端边界外的内存。


#### 2.4 分代收集算法

将Java堆分为新生代和老年代，永久代是方法区。
在新生代中，对象有大量死去少量存活，就选用复制方法，
而老年代中因为存活率高且没有额外空间对它进行分配担保，
就必须使用“标记清除”或“标记整理”来进行回收。

### 3.HotSpot的算法实现

#### 1.枚举根结点

GC Roots在全局性引用（常量或类静态属性）和执行上下文（栈帧的本地变量表）中，
如果太多的话不可能一一进行检查，太消耗时间。
同时，GC检查时会出现GC停顿，即可达性分析工作必须在一个能确保一致性的快照中进行，
此时在整个分析期间整个执行系统仿佛被冻结，对象的引用关系不会出现变化，
否则分析结果无法保证。即GC进行时必须停顿所有的Java执行线程。
目前虚拟机使用的都是准确式GC
（虚拟机自己知道内存中某个位置的具体数据是什么类型，
即知道哪些地方存放着对象引用）。在类加载完成时，
使用OopMap数据结构（OOP，普通对象指针）来进行查看对象的存放地址。
GC扫描时就可以直接得到信息。

#### 2.安全点

GC Roots枚举的问题：可能导致引用关系变化，
或者说OopMap内容变化的指令非常多。如果每一条指定都生成OopMap，
那将会需要大量的额外空间，GC的空间成本将会变很高。

安全点：没有每条指令都生成OopMap，只在特定位置记录了信息，即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。由于安全点的选定既不能太少以致于让GC等待时间太长，也不能太过于频繁以致于过分增大运行时的负荷。因此，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”来选定的。长时间运行即指令序列复用，例如方法调用、循环跳转、异常跳转等。

另一个问题是如何在GC发生时让所有线程（不包括执行JNI调用的线程）都到最近的安全点上再停顿下来。

有两种方式：抢先式中断和主动式中断。

抢先式中断即不需要线程的先执行代码主动配合，而是在GC发生时，先全部中断，然后发现有线程中断的不在安全点上，就恢复线程，让其跑到安全点上再停顿。（几乎没用这种方式。）

主动式中断： 当GC需要中断时，不直接对线程操作，仅仅简单设置一个标志，各线程主动去轮询这个标志，发现中断标志时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

     