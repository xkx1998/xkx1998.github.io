---
layout:     post
title:      Java内存区域与内存溢出异常
subtitle:   
date:       2019-1-21
author:     BY xukexiang
header-img: img/charlotte/b2f68e7ebd6314a8358661a765ca9095527eeee1.jpg
catalog: true
tags:
    - Typora
---

### 1.运行时数据区域
Java虚拟机内存模型包括程序计数器、虚拟机栈、本地方法栈、方法区、堆，如下图所示

![Java虚拟机运行时数据区](/img/2019-3-14-Java内存区域与内存溢出异常/JVM内存模型.png)

#### 1.1 程序计数器
程序计数器是一块较小的内存空间，可以看作当前线程所执行的字节码行号指示器。需要注意以下几点内容：

- 程序计数器是线程私有，各线程之间互不影响
- 如果正在执行java方法，计数器记录的是正在执行的虚拟机字节码指令地址
- 如果执行native方法，这个计数器为null
- 程序计数器也是在Java虚拟机规范中唯一没有规定任何OutOfMemoryError异常情况的区域


#### 1.2 虚拟机栈
虚拟机栈即我们平时经常说的栈内存，也是线程私有，
虚拟机栈是Java方法执行时的内存模型，每个方法在执行时都会创建一个栈帧用于储存以下内容：

- 局部变量表：32位变量槽，存放了编译期可知的各种基本数据类型、对象引用、returnAddress类型。

- 操作数栈：基于栈的执行引擎，虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。

- 动态连接：每个栈帧都包含一个指向运行时常量池（方法区的一部分）中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另一部分将在每一次的运行期间转化为直接应用，这部分称为动态连接。

- 方法出口：返回方法被调用的位置，恢复上层方法的局部变量和操作数栈，如果无返回值，则把它压入调用者的操作数栈。

#### 1.3 本地方法栈
本地方法栈是线程私有，与虚拟机栈类似，为native方法服务。

#### 1.4 方法区

线程共享，用于储存已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码，
方法区也称持久代（Permanent Generation），主要存放java类定义信息，与垃圾回收关系不大，
但不是没有垃圾回收，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。
运行时常量池，方法区的一部分，虚拟机加载Class后把常量池中的数据放入运行时常量池。

#### 1.5 堆
堆是JVM中最大的一块区域，线程共享，此区唯一的目的就是存放对象实例，
几乎所有对象实例都在这里分配，但是随着JIT编译器及逃逸分析技术的发展，
栈上分配、标量替换优化技术将会导致一些微妙的变化，所有对象都分配在堆上也渐渐变的不是那么绝对。

- \*\*新生代\*\*：包括Eden区、From Survivor区、To Survivor区，系统默认大小Eden:Survivor=8:1
- \*\*老年代\*\*：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，
可以认为年老代中存放的都是一些生命周期较长的对象。



