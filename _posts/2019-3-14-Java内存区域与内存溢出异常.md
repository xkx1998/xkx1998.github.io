---
layout:     post
title:     （JVM学习笔记一）Java内存区域与内存溢出异常
subtitle:   
date:       2019-1-21
author:     BY xukexiang
header-img: img/charlotte/b2f68e7ebd6314a8358661a765ca9095527eeee1.jpg
catalog: true
tags:
    - Typora
---

### 1.运行时数据区域
Java虚拟机内存模型包括程序计数器、虚拟机栈、本地方法栈、方法区、堆，如下图所示

![Java虚拟机运行时数据区](/img/2019-3-14-Java内存区域与内存溢出异常/JVM内存模型.png)

#### 1.1 程序计数器
程序计数器是一块较小的内存空间，可以看作当前线程所执行的字节码行号指示器。需要注意以下几点内容：

- 程序计数器是线程私有，各线程之间互不影响
- 如果正在执行java方法，计数器记录的是正在执行的虚拟机字节码指令地址
- 如果执行native方法，这个计数器为null
- 程序计数器也是在Java虚拟机规范中唯一没有规定任何OutOfMemoryError异常情况的区域


#### 1.2 虚拟机栈
虚拟机栈即我们平时经常说的栈内存，也是线程私有，
虚拟机栈是Java方法执行时的内存模型，每个方法在执行时都会创建一个栈帧用于储存以下内容：

- 局部变量表：32位变量槽，存放了编译期可知的各种基本数据类型、对象引用、returnAddress类型。

- 操作数栈：基于栈的执行引擎，虚拟机把操作数栈作为它的工作区，大多数指令都要从这里弹出数据、执行运算，然后把结果压回操作数栈。

- 动态连接：每个栈帧都包含一个指向运行时常量池（方法区的一部分）中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用一部分会在类加载阶段或第一次使用的时候转化为直接引用，这种转化称为静态解析。另一部分将在每一次的运行期间转化为直接应用，这部分称为动态连接。

- 方法出口：返回方法被调用的位置，恢复上层方法的局部变量和操作数栈，如果无返回值，则把它压入调用者的操作数栈。

#### 1.3 本地方法栈
本地方法栈是线程私有，与虚拟机栈类似，为native方法服务。

#### 1.4 方法区

线程共享，用于储存已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码，
方法区也称持久代（Permanent Generation），主要存放java类定义信息，与垃圾回收关系不大，
但不是没有垃圾回收，这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。

- 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版
  本、字段、方法、接口等描述等信息外，还有一项信息是常量池.
  （Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加
  载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量
  池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会
  被虚拟机认可、装载和执行
#### 1.5 堆
堆是JVM中最大的一块区域，线程共享，此区唯一的目的就是存放对象实例，
几乎所有对象实例都在这里分配，但是随着JIT编译器及逃逸分析技术的发展，
栈上分配、标量替换优化技术将会导致一些微妙的变化，所有对象都分配在堆上也渐渐变的不是那么绝对。

- **新生代**：包括Eden区、From Survivor区、To Survivor区，系统默认大小Eden:Survivor=8:1
- **老年代**：在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，
可以认为年老代中存放的都是一些生命周期较长的对象。


#### 1.6直接内存
直接内存(Direct Memory):并不是虚拟机运行时数据区的一部分，
而是本机直接内存.在NIO中，通过Native(本地)函数库直接分配堆外内存，
然后通过一个存储在堆中的DirectByteBuffer对象作为这块内存的引用进行操作，
避免了在Java堆和Native堆(Java堆之外的本机内存)中来回复制数据

#### 1.7对象的创建
虚拟机遇到一条new指令时，
首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，
并且检查这个符号引用代表的类是否已被加载，
解析和初始化过.如果没有，那必须先执行相应的类加载过程

- 类加载检查通过后，接下来虚拟机将为新生对象分配内存

- 内存的分配方式

1.指针碰撞(堆中的内存规整，中间一个指针作为分界点两边是用的和空闲的内存)；

2.空闲列表(堆中的内存不规整，已使用的内存和空闲的内存相互交错，
虚拟机维护一个列表记录内存可用，从列表中查找)

怎么选择？：选择哪种分配方式由java堆是否规整决定，而java堆是否规整又由
所采用的垃圾收集器是否带有压缩整理功能

- 对象的创建十分频繁，并发下非线程安全 .解决方法: 1.同步处理分配内存空间的动作；
2.把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，
称为本地线程分配缓冲(Thread Local Allocation Buffer，TLAB)。

#### 1.8 对象的内存布局
- 对象在内存中存储的布局分为3块区域:
**对象头**(Header)，**实例数据**(InstanceData)和**对齐填充**(Padding)

1.**对象头**：对象头一部分存储对象自身的运行时数据(称为Mark Word)，如哈希码，GC分代年龄，
锁状态标志，线程持有的锁，偏向锁ID，偏向时间戳；另一部分是类型指针，
即对象指向它的类元数据的指针.虚拟机通过这个指针来确定这个对象是哪个类的实例.

2.**实例数据**：实例数据部分是对象真正存储的有效信息，
也是在程序代码中所定义的各种类型的字段内容，无论是从父类继承的还是在子类定义的

3.**对齐填充**：对齐填充并不是必然存在的，
仅仅起着占位符的作用HotSpotVM的自动内存管理系统
要求对象的起始地址必须是8字节的整数倍，
而对象头部分是8字节的倍数，当实例数据部分没有对齐时就需要对齐填充部分来补全。

#### 1.9 对象的访问定位

- Java程序通过栈上的reference数据来操作堆上的具体对象.reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的对象的具体位置.所以对象的访问方式取决于虚拟机实现，
主流的访问方式有使用句柄和直接指针两种。

1.句柄:Java堆中划分一块内存作为句柄池，
reference中存储的就是对象的句柄地址.
句柄中包含了对象实例数据与类型数据各自具体的地址信息(可以把句柄看作是对象的索引)

2.直接指针:reference中存储的直接就是对象地址(比上面少了一层，
索引只在reference中)

![通过句柄和直接地址访问对象图](/img/2019-3-14-Java内存区域与内存溢出异常/20170524200028524.png)

- 两种对象访问方式各有优势，两者各有优势:使用句柄在对象被移动时，
不改变reference而只改变句柄中的实例数据指针；
而使用直接指针可以节省一次指针定位的时间开销 



#### 2.0 StackOverflowError 和 OutOfMemoryError

1、stackoverflow：

每当java程序启动一个新的线程时，java虚拟机会为他分配一个栈，java栈以帧为单位保持线程运行状态；当线程调用一个方法时，
jvm压入一个新的栈帧到这个线程的栈中，只要这个方法还没返回，这个栈帧就存在。 
如果方法的嵌套调用层次太多(如递归调用),随着java栈中的帧的增多，最终导致这个线程的栈中的所有栈帧的大小的总和大于-Xss设置的值，而产生生StackOverflowError溢出异常。
线程请求的栈深度大于虚拟机所允许的深度。

2.outofmemory

- 栈内存溢出：
java程序启动一个新线程时，没有足够的空间为改线程分配java栈，或者在扩展
栈的时候无法申请足够的内存空间。
一个线程java栈的大小由-Xss设置决定；JVM则抛出OutOfMemoryError异常。

- 堆内存溢出(OutOfMemoryError:java heap space)：
堆溢出可以分为以下两种情况，这两种情况都会抛出OutOfMemoryError:java heap space异常：

1）内存泄漏

内存泄漏是指对象实例在新建和使用完毕后，仍然被引用，没能被垃圾回收释放，一直积累，直到没有剩余内存可用。
如果内存泄露，我们要找出泄露的对象是怎么被GC ROOT引用起来，然后通过引用链来具体分析泄露的原因。
分析内存泄漏的工具有：Jprofiler，visualvm等。


2）内存溢出
内存溢出是指当我们新建一个实力对象时，实例对象所需占用的内存空间大于堆的可用空间。
如果出现了内存溢出问题，这往往是程序本生需要的内存大于了我们给虚拟机配置的内存，这种情况下，我们可以采用调大-Xmx来解决这种问题。


- 方法区内存溢出：
方法区用于存放java类的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。在类加载器加载class文件到内存中的时候，
JVM会提取其中的类信息，并将这些类信息放到方法区中。 
当需要存储这些类信息，而方法区的内存占用又已经达到最大值（通过-XX:MaxPermSize）；
将会抛出OutOfMemoryError异常对于这种情况的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。
这里需要借助CGLib直接操作字节码运行时，生成了大量的动态类。