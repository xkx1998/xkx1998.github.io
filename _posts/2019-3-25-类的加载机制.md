---
layout:     post
title:      （JVM学习笔记三）虚拟机类的加载机制
subtitle:   
date:       2019-3-25
author:     BY xukexiang
header-img: img/charlotte/b2f68e7ebd6314a8358661a765ca9095527eeee1.jpg
catalog: true
tags:
    - Typora
---

### 1.类的加载时机

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证
、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分称为连接。
![类的生命周期](/img/2019-3-25-类的加载机制/微信图片_20190325234105.png)

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的 ，
解析阶段在某些情况下可以再初始化之后在再开始，
这是为了支持java 的运行时绑定。

### 2.类的加载过程

#### 2.1 加载
***
"加载"是类加载过程的一个阶段。在加载阶段，虚拟机需要完成以下三件事情

1) 通过一个类的全限定名来获取定义此类的二进制流
2) 将这个字节流锁代表的静态存储结构转化为方法区的运行时数据结构
3) 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区
这个类的各种数据的访问入口

where&how获取二进制流？

1) 从JAR、EAR、WAR格式的包中(Tomcat就是通过部署在上边的WAR包来运行整个web项目的)
2) 从网络中获取(Applet应用)
3) 动态代理技术(java.lang.reflect.Proxy)
4) JSP文件
5) 从数据库中读取(中间件服务器SAP Netweaver)

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需要的格式存储在方法区
之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范为规定此区域的具体数据结构
。然后再内存中实例化一个java.lang.Class类的对象（并没有明确规定是在java堆中，
对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区中，
）这个对象将作为程序访问方法区中这些类型数据的外部接口。

加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的
加载阶段尚未完成，连接阶段可能已经开始了，但是这些夹在加载阶段之中进行的动作仍然属于连接阶段的内容，
这两个阶段的开始时间仍然保持着固定的先后顺序。

#### 2.2 验证

这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，
并且不会危害虚拟机自身的安全。(因为Class文件不仅仅可以由java源文件编译形成，也可以人为构造Class文件。
如果输入的字节流不符合Class文件的存储格式，抛错:java.lang.VerifyError)。

##### 2.21 文件格式验证

第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。
可能包含：

1) 是否以魔数0xCAFEBABE开头
2) 主、次版本号是否在当前虚拟机处理范围之内
3) 常量池的常量中是否有不被支持的常量类型
4) 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
5) CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据

这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入
内存的方法区中进行存储，所以后面的3个阶段全部是基于方法区的存储结构进行的，
不会再直接操作字节流。

##### 2.22 元数据验证

第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求。

1) 这个类是否有父亲(除了java.lang.Obejct之外，所有的类都应当有父类)
2) 这个类的父亲是否继承了不允许被继承的类(被final修饰的类)
3) 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
4) 类中的字段、方法是否与父类产生了矛盾

##### 2.23 字节码验证

主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。

1) 保证任意时刻操作数栈的数据类型与指令代码都能配合工作，例如不会出现类似这样的情况：
在操作栈中放置了一个int类型的数据，使用的时候却按long类型来加载到本地变量表中
2) 保证跳转指令不会跳转到方法体以外的字节码指令上
3) 保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，
这是安全的，反之则是危险的。

##### 2.24 符号验证
最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接
的第三阶段————解析阶段中发生。
符号引用验证可以看做是对类自身以外（常量池中的各种符号）的信息进行匹配性校验。目的
是确保解析动作能正常执行。通常需要校验下列内容。

1) 符号引用中通过字符串描述的全限定名是否能找到对应的类
2) 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
3) 符号引用中的类、字段和方法的访问行(private,protected,public,default)是否可被当前类访问

#### 2.3 准备

准备阶段是正式为类变量分配内存并设置变量初始值的阶段，
这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量
（被static修饰的变量），而不包括实例变量，实例变量会在对象实例化时随着随想一起分配在java堆中。并且，初始值通常情况是数据类型的零值，而不是代码中所赋予的值。

#### 2.4 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

符号引用(Symbolic References):符号引用以一组符号来描述所引用的目标，
符号可以是任何形式的字面量，只要使用时无歧义地定位到目标即可。
符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。

直接引用(Direct References):直接引用可以是直接指向目标的指针、
相对偏移量或是一个能间接定位到目标的句柄。直接引用是虚拟机实现的内存布局相关的，
同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。
如果有了直接引用，那引用的目标必定已经在内存中存在。

#### 2.5 初始化

该过程是类加载过程的最后一步。在该过程中，才开始真正执行类中定义的java代码
（注意该过程并不是对象的实例化）。

虚拟机会执行类构造器<clinit>()方法来初始化该类。简单归纳一下就是：
类的初始化：（最后一步）执行面向类的构造器（<clinit>()）

对象的初始化：执行面向对象的构造器(Constructor)，类构造器<clinit>()方法是指：该方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。
编译器收集的顺序是由语句在源文件中出现的顺序决定的。

注意：静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，
在前面的静态语句块中可以赋值，但是不能访问。

另外，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，
其它线程都需要阻塞等待。但如果执行<clinit>()方法的那条线程退出<clinit>()方法后，
其他线程唤醒之后不会进入<clinit>()方法.同一个类加载器下，一个类型只会初始化一次。



面试题：说一下类的加载机制？

妈的，学的时候感觉都懂了，说的时候感觉不是很好说。

类加载过程分为三个步骤，加载、连接、初始化。
其中连接包括验证、准备、解析。

加载就是jvm虚拟机从各个来源获取类的二进制字节流，
然后将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
最后再方法区中实例化一个Class对象作为这个类的各种数据的访问入口。

然后jvm虚拟机要验证Class文件中的字节流是否符合jvm的规范。
文件格式校验，比如文件是否是魔数开头，主次版本号等。
还有元数据校验，就是对字节码的信息作语义分析。比如
是否继承了final修饰的类。或者这个类是否有父类。
还有字节码校验，对数据流和控制流分析确定程序的语义是不是合法的。
符号校验，发生在解析阶段，

然后就是准备阶段，准备阶段是对类变量进行初始化，这里的初始化是对赋值为数据类型
的零值。对final修饰的变量赋它原本设定的值。

解析阶段就是对类和接口、方法、字段、方法类型、方法句柄等进行符号引用转化为直接引用的过程，

初始化就是执行类的构造器方法，编译器收集了类的所有类方法和静态语句块合并到一起，然后按源代码的顺序执行。
父类如果没有初始化就先初始化父类。


感觉就只能说到这了。。。